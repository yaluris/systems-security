In this assignment, the task was to exploit a buffer overflow vulnerability in a very simple but badly written 
program, based on x86 architecture. The program asks the user to enter their name and then simply greets them. 
However, the developer did not take into consideration that the user may enter a longer string than the size 
allocated for the buffer, resulting in an overflow on adjacent memory on the stack. 

The Greeter program has been compiled using (among others) the -z execstack flag, which allows code placed
in the stack to be executed. 

We initially resorted to the trial and error method to determine the necessary padding to reach the return address
of the function, which turned out to be 48 bytes. We filled up this space with the payload (shellcode), which is 21 
bytes, and used the nop instruction for the 27 bytes remaining. The return address was then set to point at the address
of the variable 'Name', on which the program copies the contents of the variable 'buf' and thus contains the shellcode. 
The shellcode is therefore executed and the program spawns a shell. To obtain the address of 'Name' we ran the program 
using GDB and used the command 'p &Name'. 

Before writing our python exploit, we ran the following C program that contained and executed the shellcode we used:  
https://shell-storm.org/shellcode/files/shellcode-575.html  
The C code was compiled by running: gcc -fno-stack-protector -z execstack -m32 -o shell_spawn shell_spawn.c

To run the Greeter program we first needed to install the gcc-multilib package.

To test the exploit, run:  
python exploit_gen.py > exploit.txt  
(cat ./exploit.txt; cat) | ./Greeter  


Bonus:

The bonus task of the assignment focused on an improved version of the Greeter program (SecGreeter) that used DEP in order 
to prevent attackers from executing the injected payload. The new version was dynamically linked and also compiled without 
the '-z execstack' flag. We once again determined the necessary padding to reach the return address of the function, equal
to 44 bytes. The padding itself is now integrated into the injected exploit, followed by a pointer to the 'system' libc 
function. We determined the address of the 'system' function using GDB and the 'p system' command. Following the address 
of the 'system' function, we added an address specified by the 'return_after_system' variable ('AAAA'). After the 'system'
function returns, the program will attempt to jump to that address, which does not point to any valid instructions. The 
next position of the stack receives the address of the '/bin/sh' string that we found using GDB and executing 
'find &system,+9999999,"/bin/sh"' to obtain it and 'x/s (address)' to print it out and confirm. This string is passed
as an argument to the 'system' function which executes the string as a shell command and spawns a shell.

Before testing the exploit, we disabled ASLR by running the following command:  
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

To test the exploit, run:  
python ret2libc_exploit_gen.py > ret2libc_exploit.txt  
(cat ./ret2libc_exploit.txt; cat) | ./SecGreeter  
